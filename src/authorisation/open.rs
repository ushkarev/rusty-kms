//! Provides any request, with a set account id and region authorisation; no checks involved

use crate::authorisation::{AuthorisationProvider, Authorisation, AuthorisationError, Access};
use crate::key_store::Key;
use crate::requests::KMSRequest;

#[derive(Debug)]
pub struct OpenAuthorisationProvider {
    region: String,
    account_id: String,
}

impl OpenAuthorisationProvider {
    pub fn new<R, A>(region: R, account_id: A) -> OpenAuthorisationProvider where R: Into<String>, A: Into<String> {
        OpenAuthorisationProvider { region: region.into(), account_id: account_id.into() }
    }
}

impl AuthorisationProvider for OpenAuthorisationProvider {
    type Authorisation = OpenAuthorisation;

    fn authorise(&self, request: &mut KMSRequest<OpenAuthorisation>) -> Result<(), AuthorisationError> {
        *request.authorisation_mut() = Some(OpenAuthorisation::new(&self.region, &self.account_id));
        Ok(())
    }
}

#[derive(Debug)]
pub struct OpenAuthorisation {
    account_id: String,
    region: String,
}

impl OpenAuthorisation {
    pub fn new(region: &str, account_id: &str) -> OpenAuthorisation {
        OpenAuthorisation { region: region.to_owned(), account_id: account_id.to_owned() }
    }
}

impl Authorisation for OpenAuthorisation {
    #[inline]
    fn region(&self) -> &str {
        &self.region
    }

    #[inline]
    fn account_id(&self) -> &str {
        &self.account_id
    }

    #[inline(always)]
    fn authorise_body(&self, _body: &str) -> Result<(), AuthorisationError> {
        Ok(())
    }

    #[inline(always)]
    fn authorises_access(&self, _key: &Key, _access: Access) -> Result<(), AuthorisationError> {
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    use http::Request;
    use hyper::body::Body;

    const BODY: &str = "{}";

    fn try_authorise(mut request: KMSRequest<OpenAuthorisation>) -> (KMSRequest<OpenAuthorisation>, Result<(), AuthorisationError>, Option<Result<(), AuthorisationError>>) {
        let provider = OpenAuthorisationProvider::new("eu-west-2", "0000000");
        let parse_result = provider.authorise(&mut request);
        let signature_result = match request.authorisation_mut() {
            Some(authorisation) => Some(authorisation.authorise_body(BODY)),
            None => None,
        };
        (request, parse_result, signature_result)
    }

    #[test]
    fn authorised() {
        let request = Request::builder()
            .method("POST")
            .uri("http://127.0.0.1:6767/")
            .header("Host", "127.0.0.1:6767")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "TrentService.ListKeys")
            .header("X-Amz-Date", "20190507T205908Z")
            // Authorization header generated by AWS cli tool
            .header("Authorization", "AWS4-HMAC-SHA256 Credential=AAAAAAAAAAAAAAAAAAAAA/20190507/eu-west-2/kms/aws4_request, SignedHeaders=content-type;host;x-amz-date;x-amz-target, Signature=5abc48718cbd3d78db8ef313386dfae0b65005fb44fe1e7ba4d25575e359c7a0")
            .body(Body::from(BODY))
            .unwrap();
        let request = KMSRequest::new(request);
        let (mut request, parse_result, signature_result) = try_authorise(request);
        assert!(parse_result.is_ok());
        assert!(signature_result.is_some());
        assert!(signature_result.unwrap().is_ok());
        assert!(request.authorisation_mut().is_some());
        if let Some(authorisation) = request.authorisation_mut() {
            assert_eq!(authorisation.region(), "eu-west-2");
            assert_eq!(authorisation.account_id(), "0000000");
        }
    }
}
